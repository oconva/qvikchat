import { z } from "zod";
import { ChatAgent } from "../agents/chat-agent";
import { defineFlow } from "@genkit-ai/flow";
import { APIKeyStore } from "../auth/api-key-store";
import { CacheStore } from "../cache/cache-store";
import { generateHash, getChatHistoryAsString } from "../utils/utils";
import { MessageData } from "@genkit-ai/ai/model";
import { apiKeyAuthPolicy } from "../auth/api-key-auth-policy";
import {
  RetrieverConfig,
  TextDataRetriever,
} from "../rag/retrievers/retriever";
import { getDataRetriever } from "../rag/retrievers/data-retriever";

type AuthParams =
  | {
      enableAuth: true;
      apiKeyStore: APIKeyStore;
    }
  | {
      enableAuth?: false;
    };

type CacheParams =
  | {
      enableCache: true;
      cacheStore: CacheStore;
    }
  | {
      enableCache?: false;
    };

type RAGParams =
  | {
      enableRAG: true;
      retrieverConfig: RetrieverConfig;
    }
  | {
      enableRAG: true;
      retriever: TextDataRetriever;
    }
  | {
      enableRAG?: false;
    };

type DefineChatFlowConfig = {
  chatAgent: ChatAgent;
  endpoint: string;
  enableChatHistory?: boolean;
} & AuthParams &
  CacheParams &
  RAGParams;

/**
 * Method to define a chat flow using the provided chat agent and endpoint, with support for chat history.
 * @param chatAgent Chat Agent instance to use for this flow.
 * @param endpoint Flow endpoint value that will be used to send requests to this flow.
 * @param enableChatHistory Enable chat history for this flow. If chat ID is provided, chat history will be fetched and used to generate response. If no chat ID is provided, a new chat ID will be generated to store chat history, and will be returned in the response.
 * @param enableAuth Enable authentication for this flow. Must provide an API Key Store instance if set to true.
 * @param apiKeyStore API Key Store instance to use for this flow.
 * @param enableCache Enable caching for this flow. Must provide a Cache Store instance if set to true.
 * @param cacheStore Cache Store instance to use for this flow.
 * @param enableRAG Enable RAG (Retrieval Augmented Generation) functionality for this flow. Must provide a retriever method if set to true.
 * @param retriever Method to retrieve documents for RAG.
 * @param retrieverConfig Configuration for the RAG retriever.
 * @returns Object containing the response generated by the chat agent and the chat ID (if available), or an error message.
 */
export const defineChatFlow = (config: DefineChatFlowConfig) =>
  defineFlow(
    {
      name: config.endpoint,
      inputSchema: z.object({
        query: z.string(),
        chatId: z.string().optional(),
        uid: config.enableAuth ? z.string() : z.string().optional(),
      }),
      outputSchema: config.enableChatHistory
        ? z.union([
            z.object({
              response: z.string(),
              chatId: z.string().optional(),
            }),
            z.object({
              error: z.string(),
            }),
          ])
        : z.union([
            z.string(),
            z.object({
              error: z.string(),
            }),
          ]),
      middleware: [
        (req, _, next) => {
          if (config.enableAuth) {
            const key = req.headers["authorization"];
            // add API key to the request object's auth property
            Object.assign(req, { auth: { key } });
          }
          next();
        },
      ],
      authPolicy: async (auth, input) => {
        console.log("Auth policy called");
        console.log("Auth:", auth);
        console.log("Input:", input);
        if (config.enableAuth) {
          // check if auth object is valid
          if (!auth || !auth.key) throw new Error("Error: Invalid API key");

          // check if user ID is provided
          if (!input.uid) throw new Error("Error: User ID not provided");

          // Verify API key and user ID
          await apiKeyAuthPolicy({
            key: auth.key,
            uid: input.uid,
            endpoint: config.endpoint,
            apiKeyStore: config.apiKeyStore,
          });
        }
      },
    },
    async ({ query, chatId }) => {
      if (query === "") return { response: "How can I help you today?" };

      // store query with context (includes the previous chat history if any, since that provides essential context)
      // will be used in caching and RAG, if enabled
      let queryWithContext = query;

      // store hash of the query for caching
      let queryHash: string = "";

      // store chat history for use in generating response later (avoids the need to fetch chat history again later)
      // only used if chat history is enabled and cache is enabled, otherwise is fetched from chat agent
      let history: MessageData[] | undefined;

      // variable to store if cache threshold has been reached for this query
      // used only if cache is enabled
      let cacheThresholdReached = false;

      // If using cache and cache store is provided
      if (config.enableCache && config.cacheStore) {
        // if chatId is provided, get chat history and add it to the query context
        if (config.enableChatHistory && chatId) {
          const chatHistory = await config.chatAgent.getChatHistory(chatId);
          if (chatHistory) {
            // add chat history to the query context
            queryWithContext += getChatHistoryAsString(chatHistory);
            // store chat history for use in generating response later
            history = chatHistory;
          }
        }
        // Generate hash of the complete query to use as a key for the cache
        queryHash = generateHash(queryWithContext);

        // validate query hash
        if (!queryHash || queryHash === "")
          return {
            error: "Error: Invalid query. Could not generate hash.",
          };

        // Check cache for the query
        const cachedQuery = await config.cacheStore.getRecord(queryHash);

        // If the query is cached, return the cached response
        if (cachedQuery) {
          // check if cached response is available
          if (cachedQuery.response) {
            console.log("Chat flow with history: returning cached response");
            return { response: cachedQuery.response, chatId };
          }

          // if response is not available, but query is in cache
          // means the cacheThreshold amount hasn't yet reached 0
          // decrement cacheThreshold to record another request for this query
          // if this decrement causes the cacheThreshold to reach 0, the query response will be cached this time
          config.cacheStore.decrementCacheThreshold(queryHash);

          // check if cacheThreshold has reached 0
          if (cachedQuery.cacheThreshold - 1 === 0) {
            // if cacheThreshold reaches 0, cache the response
            cacheThresholdReached = true;
          }
        } else {
          // if query is not in cache, add it to cache to track the number of times this query is received
          // sending hash is optional. Sending so hash doesn't have to be recalculated
          // remeber to add the query with context
          config.cacheStore.addQuery(queryWithContext, queryHash);
        }
      }

      try {
        // variable to store context, in case RAG is enabled
        let context: string | undefined;

        // If RAG enabled
        if (config.enableRAG) {
          // if retriever not provided, check if retrieverConfig is provided
          if (!("retriever" in config)) {
            // if retrieverConfig not provided, return an error
            if (!config.retrieverConfig) {
              return {
                error:
                  "Error: To enable RAG you must provide either retriever or retriever config.",
              };
            }
            // get retriever using the provided configuration
            const retriever = await getDataRetriever(config.retrieverConfig);
            // get context using the retriever
            context = await retriever.invoke(query);
          } else {
            // get context using the retriever
            context = await config.retriever.invoke(query);
          }
        }

        // Generate a response using the chat agent
        const response = await config.chatAgent.generateResponse({
          query,
          chatId,
          history,
          context,
        });

        // If using cache and cache store is provided, and
        // if cacheThreshold reaches 0 for this query, cache the response
        if (config.enableCache && config.cacheStore && cacheThresholdReached) {
          config.cacheStore.cacheResponse(queryHash, response.res.text());
        }

        return {
          response: response.res.text(),
          chatId: response.chatId,
        };
      } catch (error) {
        return {
          error: `Error: ${error}`,
        };
      }
    }
  );
