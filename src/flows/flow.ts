import { z } from 'zod';
import { ChatAgent } from '../agents/chat-agent';
import { defineFlow } from '@genkit-ai/flow';
import { APIKeyStore } from '../auth/api-key-store';
import { CacheStore } from '../cache/cache-store';
import { generateHash, getChatHistoryAsString } from '../utils/utils';
import { MessageData } from '@genkit-ai/ai/model';
import { apiKeyAuthPolicy } from '../auth/api-key-auth-policy';
import { TextDataRetriever } from '../rag/retrievers/retriever';

/**
 * Represents the parameters for defining a chat flow.
 */
export interface DefineChatFlowParams {
	/**
	 * The chat agent used for the flow.
	 */
	chatAgent: ChatAgent;

	/**
	 * The endpoint for the chat flow.
	 */
	endpoint: string;

	/**
	 * Optional flag to enable chat history.
	 */
	enableChatHistory?: boolean;

	/**
	 * Optional flag to enable authentication.
	 */
	enableAuth?: boolean;

	/**
	 * Optional API key store.
	 */
	apiKeyStore?: APIKeyStore;

	/**
	 * Optional flag to enable caching.
	 */
	enableCache?: boolean;

	/**
	 * Optional cache store.
	 */
	cacheStore?: CacheStore;

	/**
	 * Optional flag to enable RAG (Retrieve, Answer, Generate) functionality.
	 */
	enableRAG?: boolean;

	/**
	 * Optional method to retrieve documents for RAG.
	 */
	retriever?: TextDataRetriever;
}

/**
 * Method to define a chat flow using the provided chat agent and endpoint, with support for chat history.
 * @param chatAgent Chat Agent instance to use for this flow.
 * @param endpoint Flow endpoint value that will be used to send requests to this flow.
 * @param enableChatHistory Enable chat history for this flow. If chat ID is provided, chat history will be fetched and used to generate response. If no chat ID is provided, a new chat ID will be generated to store chat history, and will be returned in the response.
 * @param enableAuth Enable authentication for this flow. Must provide an API Key Store instance if set to true.
 * @param apiKeyStore API Key Store instance to use for this flow.
 * @param enableCache Enable caching for this flow. Must provide a Cache Store instance if set to true.
 * @param cacheStore Cache Store instance to use for this flow.
 * @param enableRAG Enable RAG (Retrieval Augmented Generation) functionality for this flow. Must provide a retriever method if set to true.
 * @param retriever Method to retrieve documents for RAG.
 * @returns Object containing the response generated by the chat agent and the chat ID (if available), or an error message.
 */
export const defineChatFlow = ({
	chatAgent,
	endpoint,
	enableChatHistory = false,
	enableAuth = false,
	apiKeyStore,
	enableCache = false,
	cacheStore,
	enableRAG = false,
	retriever,
}: DefineChatFlowParams) =>
	defineFlow(
		{
			name: endpoint,
			inputSchema: z.object({
				query: z.string(),
				chatId: z.string().optional(),
				uid: enableAuth ? z.string() : z.string().optional(),
			}),
			outputSchema: z.union([
				z.string(),
				z.object({
					response: z.string(),
					chatId: z.string().optional(),
				}),
				z.object({
					error: z.string(),
				}),
			]),
			middleware: [
				(req, _, next) => {
					if (enableAuth) {
						const key = req.headers['authorization'];
						// add API key to the request object's auth property
						Object.assign(req, { auth: { key } });
					}
					next();
				},
			],
			authPolicy: async (auth, input) => {
				console.log('Auth policy called');
				console.log('Auth:', auth);
				console.log('Input:', input);
				if (enableAuth) {
					// check if auth object is valid
					if (!auth || !auth.key)
						throw new Error('Error: Invalid API key');

					// check if user ID is provided
					if (!input.uid)
						throw new Error('Error: User ID not provided');

					// Verify API key and user ID
					await apiKeyAuthPolicy({
						key: auth.key,
						uid: input.uid,
						endpoint,
						apiKeyStore,
					});
				}
			},
		},
		async ({ query, chatId }) => {
			if (query === '') return { response: 'How can I help you today?' };

			// store query with context (includes the previous chat history if any, since that provides essential context)
			// will be used in caching and RAG, if enabled
			let queryWithContext = query;

			// store hash of the query for caching
			let queryHash: string = '';

			// store chat history for use in generating response later (avoids the need to fetch chat history again later)
			// only used if chat history is enabled and cache is enabled, otherwise is fetched from chat agent
			let history: MessageData[] | undefined;

			// If using cache and cache store is provided
			if (enableCache && cacheStore) {
				// if chatId is provided, get chat history and add it to the query context
				if (enableChatHistory && chatId) {
					const chatHistory = await chatAgent.getChatHistory(chatId);
					if (chatHistory) {
						// add chat history to the query context
						queryWithContext += getChatHistoryAsString(chatHistory);
						// store chat history for use in generating response later
						history = chatHistory;
					}
				}
				// Generate hash of the complete query to use as a key for the cache
				queryHash = generateHash(queryWithContext);

				// validate query hash
				if (!queryHash || queryHash === '')
					return {
						error: 'Error: Invalid query. Could not generate hash.',
					};

				// Check cache for the query
				const cachedQuery = cacheStore.getRecord(queryHash);

				// If the query is cached, return the cached response
				if (cachedQuery) {
					// check if cached response is available
					if (cachedQuery.response) {
						console.log(
							'Chat flow with history: returning cached response'
						);
						return { response: cachedQuery.response, chatId };
					}

					// if response is not available, but query is in cache
					// means the cacheThreshold amount hasn't yet reached 0
					// decrement cacheThreshold to record another request for this query
					// if this decrement causes the cacheThreshold to reach 0, the query response will be cached this time
					cacheStore.decrementCacheThreshold(queryHash);
				} else {
					// if query is not in cache, add it to cache to track the number of times this query is received
					// sending hash is optional. Sending so hash doesn't have to be recalculated
					// remeber to add the query with context
					cacheStore.addQuery(queryWithContext, queryHash);
				}
			}

			try {
				// variable to store context, in case RAG is enabled
				let context: string | undefined;

				// If using RAG and RAG retriever is provided
				if (enableRAG && retriever) {
					console.log('Retrieving context using RAG retriever');
					context = await retriever.invoke(query);
					console.log(context);
				}

				// Generate a response using the chat agent
				const response = await chatAgent.generateResponse({
					query,
					chatId,
					history,
					context,
				});

				// If using cache and cache store is provided, and
				// if cacheThreshold reaches 0 for this query, cache the response
				if (
					enableCache &&
					cacheStore &&
					cacheStore.isCacheThresholdReached(queryHash)
				) {
					cacheStore.cacheResponse(queryHash, response.res.text());
				}

				return {
					response: response.res.text(),
					chatId: response.chatId,
				};
			} catch (error) {
				return {
					error: `Error: ${error}`,
				};
			}
		}
	);
